#[macro_export]
/// [`root_span!`] creates a new [`tracing::Span`].
/// It empowers you to add custom properties to the span on top of the properties tracked
/// by [`DefaultRootSpanBuilder`].
///
/// # Why a macro?
///
/// `tracing` requires all the properties attached to a span to be declared upfront, when the span is created.
/// You cannot add new ones afterwards.
/// This makes it extremely fast, but it pushes us to reach for macros when we need some level of composition.
///
/// # Macro syntax
///
/// The first argument passed to [`root_span!`] is a reference to an [`reqwest::Request`].
///
/// ```rust
/// pub struct CustomRootSpanBuilder;
///
/// impl RootSpanBuilder for CustomRootSpanBuilder {
///     fn on_request_start(req: &Request, _extension: &mut Extensions) -> Span {
///         root_span!(req)
///     }
///
///     fn on_request_end<B>(span: &Span, outcome: &Result<Response>, _extension: &mut Extensions) {
///         // The default fields on request end are not captured automatically.
///         // You have to call the default span builder if you want them.
///         DefaultRootSpanBuilder::on_request_end(span, outcome, _extension);
///     }
/// }
/// ```
///
/// If nothing else is specified, the span generated by `root_span!` is identical to the one you'd
/// get by using [`DefaultRootSpanBuilder`].
///
/// You can define new fields following the same syntax of [`tracing::info_span!`] for fields:
///
/// ```rust,should_panic
/// use reqwest_tracing::root_span;
/// # let request: &reqwest::Request = todo!();
///
/// // Define a `time_elapsed` field as empty. It might be populated later.
/// root_span!(request, time_elapsed = tracing::field::Empty);
///
/// // Define a `name` field with a known value, `AppName`.
/// root_span!(request, name = "AppName");
///
/// // Define an `app_id` field using the variable with the same name as value.
/// let app_id = "XYZ";
/// root_span!(request, app_id);
///
/// // All together
/// root_span!(request, time_elapsed = tracing::field::Empty, name = "AppName", app_id);
/// ```
///
/// You can also choose to customise the level of the generated span:
///
/// ```rust,should_panic
/// use reqwest_tracing::root_span;
/// use tracing::Level;
/// # let request: &reqwest::Request = todo!();
///
/// // Reduce the log level for service endpoints/probes
/// let level = if req.method().as_str() == "POST" {
///     Level::DEBUG
/// } else {
///     Level::INFO
/// };
///
/// // `level =` MUST be the first argument.
/// root_span!(level = level, request);
/// ```
///
///
/// [`DefaultRootSpanBuilder`]: crate::root_span_builder::DefaultRootSpanBuilder
macro_rules! root_span {
    // Vanilla root span at default INFO level, with no additional fields
    ($request:ident) => {
        root_span!($request,)
    };
    // Vanilla root span, with no additional fields but custom level
    (level=$level:expr, $request:ident) => {
        root_span!(level=$level, $request,)
    };
    // Root span with additional fields, default INFO level
    ($request:ident, $($field:tt)*) => {
        root_span!(level=$crate::root_span_macro::private::Level::INFO, $request, $($field)*)
    };
    // Root span with additional fields and custom level
    (level=$level:expr, $request:ident, $($field:tt)*) => {
        {
            let method = $request.method();
            let scheme = $request.url().scheme();
            let host = $request.url().host_str().unwrap_or("");
            let host_port = $request.url().port().unwrap_or(0) as i64;
            let path = $request.url().path();
            let otel_name = format!("{} {}", method, path);

            macro_rules! request_span {
                ($lvl:expr) => {
                    $crate::root_span_macro::private::span!(
                        $lvl,
                        "HTTP request",
                        http.method = %method,
                        http.scheme = %scheme,
                        http.host = %host,
                        net.host.port = %host_port,
                        otel.kind = "client",
                        otel.name = %otel_name,
                        otel.status_code = tracing::field::Empty,
                        http.user_agent = tracing::field::Empty,
                        http.status_code = tracing::field::Empty,
                        error.message = tracing::field::Empty,
                        error.cause_chain = tracing::field::Empty,
                        $($field)*
                    )
                }
            }

            let span = match $level {
                $crate::root_span_macro::private::Level::TRACE => {
                    request_span!($crate::root_span_macro::private::Level::TRACE)
                },
                $crate::root_span_macro::private::Level::DEBUG => {
                    request_span!($crate::root_span_macro::private::Level::DEBUG)
                },
                $crate::root_span_macro::private::Level::INFO => {
                    request_span!($crate::root_span_macro::private::Level::INFO)
                },
                $crate::root_span_macro::private::Level::WARN => {
                    request_span!($crate::root_span_macro::private::Level::WARN)
                },
                $crate::root_span_macro::private::Level::ERROR => {
                    request_span!($crate::root_span_macro::private::Level::ERROR)
                },
            };
            span
        }
    }
}

#[doc(hidden)]
pub mod private {
    #[doc(hidden)]
    pub use tracing::{span, Level};
}
